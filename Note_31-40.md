#### 1031

无难度，注意整数除法进一法。

#### 1032

哈希表存储节点地址和下一节点的地址。遍历两个单词，存储地址到list中。当list中出现已存在的地址，输出该地址，退出程序。

测试点3为一个单词的情况，测试点4为两个单词完全相同的情况。

测试点5超时问题暂未解决。

#### 1033

核心算法：贪心

查找能到达的站点中，是否有比当前站点更便宜的站点

一旦出现了比当前站点更便宜的站点，将此站点作为下一个目标；当前站点所加的油量为刚好能到达下一目标的油量（两站点距离/每公里耗油量-当前剩下的油量）；更新记录到达下一目标时剩下的油量（0）；

若没有出现比当前站点更便宜的站点，将能到达的站点中最便宜的站点作为下一个目标；当前站点所加油量为尽可能加得多（容量-当前剩下的油量）；更新记录到达下一目标时剩下的油量（容量-两站点距离/每公里耗油量）；

每次判断是否能达到下一站点；将终点当作是油价为0的站点；

使用`StreamTokenizer`提高效率；

for语句中双重判断

````java
for(int i = now+1;i<list.size()&&list.get(i).distance<=(list.get(now).distance+capacity*gasrun);i++)
````

特别注意，对于双精度的计算，每个站点的距离也要用双精度存储。否则在油耗和加油量的计算中可能会出现错误。、


#### 1035

无难度。测试点2没通过原因是没有注意英文语法单复数。
#### 1036

无难度。注意审题是最高的女生和最低的男生之间的成绩差。

#### 1037

无难度。使用`StreamTokenizer`作为IO一遍过。

#### 1038

###### first attempt

`String.compareTo()`方法实现对字符串的字典排序。

特别的，对于一个字符串是另一个字符串子串的情况（`String.contain()`方法判断），若较长字符串中除子字符串的字符外第一个字符小于其第一个字符，将其排在之前；

使用正则表达式去除首位的0

````java
System.out.println(sb.toString().replaceFirst("^0+(?!$)", ""));
````

###### second attempt

参考博客，事实上对于子串的情况，比较`s1+s2`和`s2+s1`的情况便可。事实上对于所有情况，都只需要使用`(s1+s2).compareTo(s2+s1)`进行比较。但是判断如果不判断子串会导致测试点6超时。。。

故采用判断是否为子串；再使用`compareTo`方法进行比较。

#### 1039

###### first attempt

`HashMap`存储各个姓名对应的课程。测试点5运行超时。

###### second attempt




#### 1041
使用`StreamTokenizer`提高读取速度，通过所有测试。